/// <reference types="node" />
import { type Bot } from "../bot.js";
import { type Update } from "../platform.node.js";
import { type Context } from "../context.js";
declare const adapters: {
    callback: FrameworkAdapter;
    http: (req: import("http").IncomingMessage, res: import("http").ServerResponse) => {
        update: Promise<any>;
        header: string;
        end: () => import("http").ServerResponse;
        respond: (json: string) => import("http").ServerResponse;
        unauthorized: () => import("http").ServerResponse;
    };
    https: (req: import("http").IncomingMessage, res: import("http").ServerResponse) => {
        update: Promise<any>;
        header: string;
        end: () => import("http").ServerResponse;
        respond: (json: string) => import("http").ServerResponse;
        unauthorized: () => import("http").ServerResponse;
    };
    express: (req: any, res: any) => {
        update: Promise<any>;
        header: any;
        end: () => any;
        respond: (json: string) => void;
        unauthorized: () => void;
    };
    koa: (ctx: any) => {
        update: Promise<any>;
        header: any;
        end: () => void;
        respond: (json: string) => void;
        unauthorized: () => void;
    };
    fastify: (req: any, reply: any) => {
        update: Promise<any>;
        header: any;
        end: () => any;
        respond: (json: string) => any;
        unauthorized: () => any;
    };
    worktop: (req: any, res: any) => {
        update: Promise<any>;
        header: any;
        end: () => any;
        respond: (json: string) => any;
        unauthorized: () => any;
    };
    "aws-lambda": (event: any, _context: any, callback: any) => {
        update: any;
        header: any;
        end: () => any;
        respond: (json: string) => any;
        unauthorized: () => any;
    };
};
/**
 * HTTP Web frameworks for which grammY provides compatible callback out of the
 * box.
 */
declare type SupportedFrameworks = keyof typeof adapters;
/**
 * Abstraction over a request-response cycle, provding access to the update, as
 * well as a mechanism for responding to the request and to end it.
 */
interface ReqResHandler {
    /**
     * The update object sent from Telegram, usually resolves the request's JSON
     * body
     */
    update: Promise<Update>;
    /**
     * X-Telegram-Bot-Api-Secret-Token header of the request, or undefined if
     * not present
     */
    header?: string;
    /**
     * Ends the request immediately without body, called after every request
     * unless a webhook reply was performed
     */
    end?: () => void;
    /**
     * Sends the specified JSON as a payload in the body, used for webhook
     * replies
     */
    respond: (json: string) => unknown | Promise<unknown>;
    /**
     * Responds that the request is unauthorized due to mismatching
     * X-Telegram-Bot-Api-Secret-Token headers
     */
    unauthorized: () => unknown | Promise<unknown>;
    /**
     * Some frameworks (e.g. Deno's std/http `listenAndServe`) assume that
     * handler returns something
     */
    handlerReturn?: any;
}
/**
 * Middleware for a web framework. Creates a request-response handler for a
 * request. The handler will be used to integrate with the compatible framework.
 */
export declare type FrameworkAdapter = (...args: any[]) => ReqResHandler;
export interface WebhookOptions {
    /** An optional strategy to handle timeouts (default: 'throw') */
    onTimeout?: "throw" | "return" | ((...args: any[]) => unknown);
    /** An optional number of timeout milliseconds (default: 10_000) */
    timeoutMilliseconds?: number;
    /** An optional string to compare to X-Telegram-Bot-Api-Secret-Token */
    secretToken?: string;
}
/**
 * Creates a callback function that you can pass to a web framework (such as
 * express) if you want to run your bot via webhooks. Use it like this:
 * ```ts
 * const app = express() // or whatever you're using
 * const bot = new Bot('<token>')
 *
 * app.use(webhookCallback(bot, 'express'))
 * ```
 *
 * Confer the grammY
 * [documentation](https://grammy.dev/guide/deployment-types.html) to read more
 * about how to run your bot with webhooks.
 *
 * @param bot The bot for which to create a callback
 * @param adapter An optional string identifying the framework (default: 'express')
 * @param onTimeout An optional strategy to handle timeouts (default: 'throw')
 * @param timeoutMilliseconds An optional number of timeout milliseconds (default: 10_000)
 */
export declare function webhookCallback<C extends Context = Context>(bot: Bot<C>, adapter?: SupportedFrameworks | FrameworkAdapter, onTimeout?: WebhookOptions["onTimeout"], timeoutMilliseconds?: WebhookOptions["timeoutMilliseconds"], secretToken?: WebhookOptions["secretToken"]): (...args: any[]) => any;
export declare function webhookCallback<C extends Context = Context>(bot: Bot<C>, adapter?: SupportedFrameworks | FrameworkAdapter, webhookOptions?: WebhookOptions): (...args: any[]) => any;
export {};
