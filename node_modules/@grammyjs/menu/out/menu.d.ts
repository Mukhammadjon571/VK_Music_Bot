import { Context, Filter, InlineKeyboardButton, InlineKeyboardMarkup, LoginUrl, Middleware, MiddlewareObj } from "./deps.node.js";
/**
 * Context flavor for context objects in listeners that react to menus. Provides
 * `ctx.menu`, a control pane for the respective menu.
 */
export interface MenuFlavor {
    match?: string;
    /**
     * Control panel for the currently active menu. `ctx.menu` is only available
     * for listeners that are passed as handlers to a menu, and it allows you to
     * perform simple actions such as navigating the menu, or updating or
     * closing it.
     *
     * As an example, if you have a text button that changes its label based on
     * `ctx`, then you should call
     *
     * ```ts
     * ctx.menu.update()
     * ```
     *
     * whenever you alter the context object in such a way that the label should
     * update. The same is true for dynamic ranges that change their layout.
     *
     * If you edit the message yourself after calling one of the functions on
     * `ctx.menu`, the new menu will be automatically injected into the payload.
     * Otherwise, a dedicated API call will be performed after your middleware
     * completes.
     */
    menu: MenuControlPanel;
}
/**
 * Menu control panel. Can be used to update or close the menu, or to perform
 * manual navigation between menus.
 */
export interface MenuControlPanel {
    /**
     * Call this method to update the menu. For instance, if you have a button
     * that changes its text based on `ctx`, then you should call this method to
     * update it.
     *
     * Calling this method will guarantee that the menu is updated, but note
     * that this will perform the update lazily. A new menu is injected into the
     * payload of the request the next time you edit the corresponding message.
     * If you let your middleware complete without editing the message itself
     * again, a dedicated API call will be performed that updates the menu.
     *
     * Pass `{ immediate: true }` to perform the update eagerly instead of
     * lazily. A dedicated API call that updates the menu is sent immediately.
     * In that case, the method returns a Promise that you should `await`. Eager
     * updating may cause flickering of the menu, and it may be slower in some
     * cases.
     */
    update(config: {
        immediate: true;
    }): Promise<void>;
    update(config?: {
        immediate?: false;
    }): void;
    /**
     * Closes the menu. Removes all buttons underneath the message.
     *
     * Calling this method will guarantee that the menu is closed, but note that
     * this will be done lazily. A new menu is injected into the payload of the
     * request the next time you edit the corresponding message. If you let your
     * middleware complete without editing the message itself again, a dedicated
     * API call will be performed that closes the menu.
     *
     * Pass `{ immediate: true }` to perform the update eagerly instead of
     * lazily. A dedicated API call that updates the menu is sent immediately.
     * In that case, the method returns a Promise that you should `await`. Eager
     * closing may be slower in some cases.
     */
    close(config: {
        immediate: true;
    }): Promise<void>;
    close(config?: {
        immediate?: false;
    }): void;
    /**
     * Navigates to the parent menu. By default, the parent menu is the menu on
     * which you called `register` when installing this menu.
     *
     * Throws an error if this menu does not have a parent menu.
     *
     * Calling this method will guarantee that the navigation is performed, but
     * note that this will be done lazily. A new menu is injected into the
     * payload of the request the next time you edit the corresponding message.
     * If you let your middleware complete without editing the message itself
     * again, a dedicated API call will be performed that performs the
     * navigation.
     *
     * Pass `{ immediate: true }` to navigate eagerly instead of lazily. A
     * dedicated API call is sent immediately. In that case, the method returns
     * a Promise that you should `await`. Eager navigation may cause flickering
     * of the menu, and it may be slower in some cases.
     */
    back(config: {
        immediate: true;
    }): Promise<void>;
    back(config?: {
        immediate?: false;
    }): void;
    /**
     * Navigates to the specified submenu. The given identifier is the same
     * string that you pass to `new Menu('')`. If you specify the identifier of
     * the current menu itself, this method is equivalent to
     * `ctx.menu.update()`.
     *
     * Remember that you must register all submenus at the root menu using the
     * `register` method before you can navigate between them.
     *
     * Calling this method will guarantee that the navigation is performed, but
     * note that this will be done lazily. A new menu is injected into the
     * payload of the request the next time you edit the corresponding message.
     * If you let your middleware complete without editing the message itself
     * again, a dedicated API call will be performed that performs the
     * navigation.
     *
     * Pass `{ immediate: true }` to navigate eagerly instead of lazily. A
     * dedicated API call is sent immediately. In that case, the method returns
     * a Promise that you should `await`. Eager navigation may cause flickering
     * of the menu, and it may be slower in some cases.
     */
    nav(to: string, config: {
        immediate: true;
    }): Promise<void>;
    nav(to: string, config?: {
        immediate?: false;
    }): void;
}
/**
 * Middleware that has access to the `ctx.menu` control panel.
 */
declare type MenuMiddleware<C extends Context> = Middleware<Filter<C, "callback_query:data"> & MenuFlavor>;
/** A value, or a promise of a value */
declare type MaybePromise<T> = T | Promise<T>;
/** A potentially async function that takes a context and returns a string */
declare type DynamicString<C extends Context> = (ctx: C) => MaybePromise<string>;
/** A potentially dynamic string */
declare type MaybeDynamicString<C extends Context> = string | DynamicString<C>;
/** An object containing text and payload */
interface TextAndPayload<C extends Context> {
    /** Text to display */
    text: MaybeDynamicString<C>;
    /** Optional payload */
    payload?: MaybeDynamicString<C>;
}
/** A dynamic string, or an object with a text and a payload */
declare type MaybePayloadString<C extends Context> = MaybeDynamicString<C> | TextAndPayload<C>;
declare type Cb<C extends Context> = Omit<InlineKeyboardButton.CallbackButton, "callback_data"> & {
    /**
     * Middleware that will be invoked if a callback query for this button
     * is received.
     */
    middleware: MenuMiddleware<C>[];
    /**
     * Optional payload for this button
     */
    payload?: MaybeDynamicString<C>;
};
declare type NoCb = Exclude<InlineKeyboardButton, InlineKeyboardButton.CallbackButton>;
declare type RemoveAllTexts<T> = T extends {
    text: string;
} ? Omit<T, "text"> : T;
/**
 * Button of a menu. Almost the same type as InlineKeyboardButton but with texts
 * that can be generated on the fly, and middleware for callback buttons.
 */
export declare type MenuButton<C extends Context> = {
    /**
     * Label text on the button, or a function that can generate this text. The
     * function is supplied with the context object that is used to make the
     * request.
     */
    text: MaybeDynamicString<C>;
} & RemoveAllTexts<NoCb | Cb<C>>;
/**
 * Raw menu range, i.e. a two-dimensional array of menu buttons.
 */
declare type RawRange<C extends Context> = MenuButton<C>[][];
/**
 * Range instance, or a raw (static) range that consists of a two-dimensional
 * menu button array.
 */
declare type MaybeRawRange<C extends Context> = MenuRange<C> | RawRange<C>;
/**
 * Potentially async function that generates a potentially raw range.
 */
declare type DynamicRange<C extends Context> = (ctx: C) => MaybePromise<MaybeRawRange<C>>;
/**
 * Potentially dynamic range.
 */
declare type MaybeDynamicRange<C extends Context> = MaybeRawRange<C> | DynamicRange<C>;
declare const ops: unique symbol;
/**
 * A menu range is a two-dimensional array of menu buttons.
 *
 * This array is a part of the total two-dimensional array of menu buttons. This
 * is mostly useful if you want to dynamically generate the structure of the
 * menu on the fly.
 */
export declare class MenuRange<C extends Context> {
    /** Internal list of range generator functions */
    [ops]: MaybeDynamicRange<C>[];
    /**
     * This method is used internally whenever a new range is added.
     *
     * @param range A range object or a two-dimensional array of menu buttons
     */
    addRange(...range: MaybeDynamicRange<C>[]): this;
    /**
     * This method is used internally whenever new buttons are added. Adds the
     * buttons to the current row.
     *
     * @param btns Menu button object
     */
    add(...btns: MenuButton<C>[]): this;
    /**
     * Adds a 'line break'. Call this method to make sure that the next added
     * buttons will be on a new row.
     */
    row(): this;
    /**
     * Adds a new URL button. Telegram clients will open the provided URL when
     * the button is pressed. Note that they will not notify your bot when that
     * happens, so you cannot react to this button.
     *
     * @param text The text to display
     * @param url HTTP or tg:// url to be opened when button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings.
     */
    url(text: MaybeDynamicString<C>, url: string): this;
    /**
     * Adds a new text button. You may pass any number of listeners. They will
     * be called when the button is pressed.
     *
     * ```ts
     * menu.text('Hit me!', ctx => ctx.reply('Ouch!'))
     * ```
     *
     * If you pass several listeners, make sure that you understand what
     * [middleware](https://grammy.dev/guide/middleware.html) is.
     *
     * You can also use this method to register a button that depends on the
     * current context.
     *
     * ```ts
     * function greetInstruction(ctx: Context): string {
     *   const username = ctx.from?.first_name
     *   return `Greet ${username ?? 'me'}!`,
     * }
     *
     * const menu = new Menu('my-menu')
     *   .text(greetInstruction, ctx => ctx.reply("I'm too shy."))
     * bot.use(menu)
     *
     * // This will send a menu with one text button, and the text has the name
     * // of the user that the bot is replying to.
     * bot.on('message', ctx => ctx.reply('What shall I do?', { reply_markup: menu }))
     * ```
     *
     * If you base the text on [session
     * data](https://grammy.dev/plugins/session.html), you can easily create a
     * settings panel with toggle buttons.
     *
     * ```ts
     * // Button will toggle between 'Yes' and 'No' when pressed
     * menu.text(ctx => ctx.session.flag ? 'Yes' : 'No', async ctx => {
     *   ctx.session.flag = !ctx.session.flag
     *   await ctx.menu.update()
     * })
     * ```
     *
     * @param text The text to display, or a text with payload
     * @param middleware The listeners to call when the button is pressed
     */
    text(text: MaybeDynamicString<C>, ...middleware: MenuMiddleware<C>[]): this;
    text(text: TextAndPayload<C>, ...middleware: MenuMiddleware<C & {
        match: string;
    }>[]): this;
    text(text: MaybePayloadString<C>, ...middleware: MenuMiddleware<C>[]): this;
    /**
     * Adds a new web app button, confer https://core.telegram.org/bots/webapps
     *
     * @param text The text to display
     * @param url An HTTPS URL of a Web App to be opened with additional data
     */
    webApp(text: string, url: string): this;
    /**
     * Adds a new login button. This can be used as a replacement for the
     * Telegram Login Widget. You must specify an HTTPS URL used to
     * automatically authorize the user.
     *
     * @param text The text to display
     * @param loginUrl The login URL as string or `LoginUrl` object
     */
    login(text: MaybeDynamicString<C>, loginUrl: string | LoginUrl): this;
    /**
     * Adds a new inline query button. Telegram clients will let the user pick a
     * chat when this button is pressed. This will start an inline query. The
     * selected chat will be prefilled with the name of your bot. You may
     * provide a text that is specified along with it.
     *
     * Your bot will in turn receive updates for inline queries. You can listen
     * to inline query updates like this:
     * ```ts
     * // Listen for specifc query
     * bot.inlineQuery('my-query', ctx => { ... })
     * // Listen for any query
     * bot.on('inline_query', ctx => { ... })
     * ```
     *
     * @param text The text to display
     * @param query The (optional) inline query string to prefill
     */
    switchInline(text: MaybeDynamicString<C>, query?: string): this;
    /**
     * Adds a new inline query button that acts on the current chat. The
     * selected chat will be prefilled with the name of your bot. You may
     * provide a text that is specified along with it. This will start an inline
     * query.
     *
     * Your bot will in turn receive updates for inline queries. You can listen
     * to inline query updates like this:
     * ```ts
     * // Listen for specifc query
     * bot.inlineQuery('my-query', ctx => { ... })
     * // Listen for any query
     * bot.on('inline_query', ctx => { ... })
     * ```
     *
     * @param text The text to display
     * @param query The (optional) inline query string to prefill
     */
    switchInlineCurrent(text: MaybeDynamicString<C>, query?: string): this;
    /**
     * Adds a new game query button, confer
     * https://core.telegram.org/bots/api#games
     *
     * This type of button must always be the first button in the first row.
     *
     * @param text The text to display
     */
    game(text: MaybeDynamicString<C>): this;
    /**
     * Adds a new payment button, confer
     * https://core.telegram.org/bots/api#payments
     *
     * This type of button must always be the first button in the first row and can only be used in invoice messages.
     *
     * @param text The text to display
     */
    pay(text: MaybeDynamicString<C>): this;
    /**
     * Adds a button that navigates to a given submenu when pressed. You can
     * pass in the identifier of another menu instance. This way, you can
     * effectively create a network of menus with navigation between them.
     *
     * It is necessary that you register the targeted submenu by calling
     * `menu.register(submenu)`. Otherwise, no navigation can be performed. Note
     * that you then don't need to call `bot.use(submenu)` anymore, all
     * registered submenus will automatically become interactive, too.
     *
     * You can also navigate to this submenu manually by calling
     * `ctx.menu.nav('sub-id')`, where `'sub-id'` is the identifier of the
     * submenu.
     *
     * You can call `submenu.back()` to add a button that navigates back to the
     * parent menu, i.e. the menu at which you registered the submenu.
     *
     * You can get back the `submenu` instance by calling `parent.at('sub-id')`,
     * where `'sub-id'` is the identifier you passed to the submenu.
     *
     * @param text The text to display, or a text with payload
     * @param menu The identifier of the submenu to open
     * @param middleware The listeners to call when the button is pressed
     */
    submenu(text: MaybeDynamicString<C>, menu: string, ...middleware: MenuMiddleware<C>[]): this;
    submenu(text: TextAndPayload<C>, menu: string, ...middleware: MenuMiddleware<C & {
        match: string;
    }>[]): this;
    submenu(text: MaybePayloadString<C>, menu: string, ...middleware: MenuMiddleware<C>[]): this;
    /**
     * Adds a text button that performs a navigation to the parent menu via
     * `ctx.menu.back()`.
     *
     * @param text The text to display, or a text with payload
     * @param middleware The listeners to call when the button is pressed
     */
    back(text: MaybeDynamicString<C>, ...middleware: MenuMiddleware<C>[]): this;
    back(text: TextAndPayload<C>, ...middleware: MenuMiddleware<C & {
        match: string;
    }>[]): this;
    back(text: MaybePayloadString<C>, ...middleware: MenuMiddleware<C>[]): this;
    /**
     * This is a dynamic way to initialize menu. A typical use case is when you
     * want to create an arbitrary menu, using the data from `ctx.session`:
     *
     * ```ts
     * const menu = new Menu('root')
     * menu.dynamic(ctx => ctx.session.data.reduce((range, entry) => range.text(entry)), new Menu.Builder())
     * bot.command("start", async (ctx) => {
     *   await ctx.reply("Menu", {
     *      reply_markup: menu,
     *   });
     * });
     * ```
     *
     * @param menuFactory Async menu factory function
     */
    dynamic(rangeBuilder: (ctx: C, range: MenuRange<C>) => MaybePromise<MaybeRawRange<C> | void>): this;
    /**
     * Appends a given range to this range. This will effectively replay all
     * operations of the given range onto this range.
     *
     * @param range A potentially raw range
     */
    append(range: MaybeRawRange<C>): this;
}
/**
 * Configuration options for the menu.
 */
export interface MenuOptions<C extends Context> {
    /**
     * Menus will automatically call `ctx.answerCallbackQuery` with no
     * arguments. If you want to call the method yourself, for example because
     * you need to send custom messages, you can set `autoAnswer` to `false` to
     * disable this behavior.
     */
    autoAnswer?: boolean;
    /**
     * A menu is rendered once when it is sent, and once when a callback query
     * arrives. After all, we could not store all rendered menus in all chats
     * forever.
     *
     * If a user presses a button on an old menu instance far up the chat, the
     * buttons may have changed completely by now, and the menu would be
     * rendered differently today. Consequently, this menu plugin can detect if
     * the menu rendered based on the newly incoming callback query is the same
     * as the menu that was sent originally.
     *
     * If the menu is found to be outdated, no handlers are run. Instead, the
     * old message is updated and a fresh menu is put into place. A notification
     * is shown to the user that the menu was outdated. Long story short, you
     * can use this option to personalize what notification to display. You can
     * pass a string as the message to display to the user.
     *
     * Alternatively, you can specify custon middleware that will be invoked and
     * that can handle this case as you wish. You should update the menu
     * yourself, or send a new message with the updated menu.
     *
     * The default behavior is to display this message, and to update the menu:
     * “Menu was outdated, try again!”
     *
     * You can set `onMenuOutdated` to `false` to disable checks for outdated
     * menus altogether. In that case, the menu will behave as if the message
     * was no outdated, and run all handlers regardless.
     */
    onMenuOutdated?: string | boolean | MenuMiddleware<C>;
    /**
     * Fingerprint function that lets you generate a unique string every time a
     * menu is rendered. Used to determine if a menu is outdated. If specified,
     * replaces the built-in heuristic.
     *
     * The built-in heuristic that determines whether a menu is outdated takes
     * the following things into account:
     * - identifier of the menu
     * - shape of the menu
     * - position of the pressed button
     * - potential payload
     * - text of the pressed button
     *
     * If all of these things are identical but the menu is still outdated, you
     * can use this option to supply the neccessary data that lets the menu
     * plugin determine more accurately if the menu is outdated. Similarly, if
     * any of these things differ but you want to consider the menu to be up to
     * date, you can also use this option to signal that.
     *
     * In other words, specifying a fingerprint function will replace the above
     * heuristic entirely by your own implementation.
     */
    fingerprint?: DynamicString<C>;
}
/**
 * A menu is a set of interactive buttons that is displayed beneath a message.
 * It uses an [inline keyboard](https://grammy.dev/plugins/keyboard.html) for
 * that, so in a sense, a menu is just an inline keyboard spiced up with
 * interactivity (such as navigation between multiple pages).
 *
 * ```ts
 * // Creating a simple menu
 * const menu = new Menu('my-menu-identifier')
 *   .text('A', ctx => ctx.reply('You pressed A!')).row()
 *   .text('B', ctx => ctx.reply('You pressed B!'))
 *
 * // Make it interactive
 * bot.use(menu)
 *
 * bot.command('start', async ctx => {
 *   // Send the menu:
 *   await ctx.reply('Check out this menu:', {
 *     reply_markup: menu
 *   })
 * })
 * ```
 *
 * Sending the menu is not directly possible via `bot.api.sendMessage`, only via
 * the context object, at least not yet.
 *
 * Check out the [official documentation](https://grammy.dev/plugins/menu.html)
 * to see how you can create menus that span several pages, how to navigate
 * between them, and more.
 */
export declare class Menu<C extends Context = Context> extends MenuRange<C> implements MiddlewareObj<C>, InlineKeyboardMarkup {
    private readonly id;
    private parent;
    private index;
    private readonly options;
    /**
     * Creates a new menu with the given identifier.
     *
     * Check out the [official
     * documentation](https://grammy.dev/plugins/menu.html) to see how you can
     * create menus that span several pages, how to navigate between them, and
     * more.
     *
     * @param id Identifier of the menu
     * @param options Further configuration options
     */
    constructor(id: string, options?: MenuOptions<C>);
    /**
     * Used internally by the menu, do not touch or you'll burn yourself.
     */
    readonly inline_keyboard: never[];
    /**
     * Registers a submenu. This makes it accessible for navigation, and sets
     * its parent menu to `this` menu.
     *
     * Optionally, you can specify the identifier of a different parent menu as
     * a second argument. The parent menu is the menu that is targeted when
     * backwards navigation is performed.
     *
     * Note that once you registered a submenu, it is sufficient to call
     * `bot.use(menu)` for the parent menu only. You do not need to make all
     * submenus interactive by passing them to `bot.use`.
     *
     * @param menus The menu to register, or an array of them
     * @param parent An optional parent menu identifier
     */
    register(menus: Menu<C> | Menu<C>[], parent?: string): void;
    /**
     * Prevents this menu from being modified further in the future.
     */
    private freeze;
    /**
     * Returns the menu instance for the given identifier. If the identifier is
     * the same as this menu's identifier, `this` is returned.
     *
     * @param id Menu identifier
     * @returns The identified menu
     */
    at(id: string): Menu<C>;
    /**
     * Renders the menu to a static object of inline keyboard buttons by
     * concatenating all ranges, and applying the given context object to all
     * functions.
     *
     * @param ctx Context object to use
     */
    private render;
    /**
     * Replaces known menu instances in the payload by their rendered versions.
     * A menu is known if it is contained in this menu's index. Only the
     * `reply_markup` property of the given object is checked for containing a
     * menu.
     *
     * @param payload Payload of API call
     * @param ctx Context object
     */
    private prepare;
    middleware(): import("grammy/out/composer").MiddlewareFn<C>;
    private makeNavInstaller;
}
export {};
