"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Menu = exports.MenuRange = void 0;
const deps_node_js_1 = require("./deps.node.js");
const b = 0xff; // mask for lowest byte
const toNums = (str) => Array.from(str).map((c) => c.codePointAt(0));
const dec = new TextDecoder();
/** Efficiently computes a 4-byte hash of an int32 array */
function tinyHash(nums) {
    // Inspired by JDK7's hashCode with different primes for a better distribution
    let hash = 17;
    for (const n of nums)
        hash = ((hash << 5) + (hash << 2) + hash + n) >>> 0; // hash = 37 * hash + n
    const bytes = [hash >>> 24, (hash >> 16) & b, (hash >> 8) & b, hash & b];
    return dec.decode(Uint8Array.from(bytes)); // turn bytes into string
}
const INJECT_METHODS = new Set([
    "editMessageText",
    "editMessageCaption",
    "editMessageMedia",
    "editMessageReplyMarkup",
    "stopPoll",
]);
const ops = Symbol("menu building operations");
/**
 * A menu range is a two-dimensional array of menu buttons.
 *
 * This array is a part of the total two-dimensional array of menu buttons. This
 * is mostly useful if you want to dynamically generate the structure of the
 * menu on the fly.
 */
class MenuRange {
    constructor() {
        /** Internal list of range generator functions */
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    /**
     * This method is used internally whenever a new range is added.
     *
     * @param range A range object or a two-dimensional array of menu buttons
     */
    addRange(...range) {
        this[ops].push(...range);
        return this;
    }
    /**
     * This method is used internally whenever new buttons are added. Adds the
     * buttons to the current row.
     *
     * @param btns Menu button object
     */
    add(...btns) {
        return this.addRange([btns]);
    }
    /**
     * Adds a 'line break'. Call this method to make sure that the next added
     * buttons will be on a new row.
     */
    row() {
        return this.addRange([[], []]);
    }
    /**
     * Adds a new URL button. Telegram clients will open the provided URL when
     * the button is pressed. Note that they will not notify your bot when that
     * happens, so you cannot react to this button.
     *
     * @param text The text to display
     * @param url HTTP or tg:// url to be opened when button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings.
     */
    url(text, url) {
        return this.add({ text, url });
    }
    text(text, ...middleware) {
        return this.add(typeof text === "object"
            ? { ...text, middleware }
            : { text, middleware });
    }
    /**
     * Adds a new web app button, confer https://core.telegram.org/bots/webapps
     *
     * @param text The text to display
     * @param url An HTTPS URL of a Web App to be opened with additional data
     */
    webApp(text, url) {
        return this.add({ text, web_app: { url } });
    }
    /**
     * Adds a new login button. This can be used as a replacement for the
     * Telegram Login Widget. You must specify an HTTPS URL used to
     * automatically authorize the user.
     *
     * @param text The text to display
     * @param loginUrl The login URL as string or `LoginUrl` object
     */
    login(text, loginUrl) {
        return this.add({
            text,
            login_url: typeof loginUrl === "string"
                ? { url: loginUrl }
                : loginUrl,
        });
    }
    /**
     * Adds a new inline query button. Telegram clients will let the user pick a
     * chat when this button is pressed. This will start an inline query. The
     * selected chat will be prefilled with the name of your bot. You may
     * provide a text that is specified along with it.
     *
     * Your bot will in turn receive updates for inline queries. You can listen
     * to inline query updates like this:
     * ```ts
     * // Listen for specifc query
     * bot.inlineQuery('my-query', ctx => { ... })
     * // Listen for any query
     * bot.on('inline_query', ctx => { ... })
     * ```
     *
     * @param text The text to display
     * @param query The (optional) inline query string to prefill
     */
    switchInline(text, query = "") {
        return this.add({ text, switch_inline_query: query });
    }
    /**
     * Adds a new inline query button that acts on the current chat. The
     * selected chat will be prefilled with the name of your bot. You may
     * provide a text that is specified along with it. This will start an inline
     * query.
     *
     * Your bot will in turn receive updates for inline queries. You can listen
     * to inline query updates like this:
     * ```ts
     * // Listen for specifc query
     * bot.inlineQuery('my-query', ctx => { ... })
     * // Listen for any query
     * bot.on('inline_query', ctx => { ... })
     * ```
     *
     * @param text The text to display
     * @param query The (optional) inline query string to prefill
     */
    switchInlineCurrent(text, query = "") {
        return this.add({ text, switch_inline_query_current_chat: query });
    }
    /**
     * Adds a new game query button, confer
     * https://core.telegram.org/bots/api#games
     *
     * This type of button must always be the first button in the first row.
     *
     * @param text The text to display
     */
    game(text) {
        return this.add({ text, callback_game: {} });
    }
    /**
     * Adds a new payment button, confer
     * https://core.telegram.org/bots/api#payments
     *
     * This type of button must always be the first button in the first row and can only be used in invoice messages.
     *
     * @param text The text to display
     */
    pay(text) {
        return this.add({ text, pay: true });
    }
    submenu(text, menu, ...middleware) {
        return this.text(text, middleware.length === 0
            ? (ctx) => ctx.menu.nav(menu)
            : (ctx, next) => (ctx.menu.nav(menu), next()), ...middleware);
    }
    back(text, ...middleware) {
        return this.text(text, middleware.length === 0
            ? (ctx) => ctx.menu.back()
            : (ctx, next) => (ctx.menu.back(), next()), ...middleware);
    }
    /**
     * This is a dynamic way to initialize menu. A typical use case is when you
     * want to create an arbitrary menu, using the data from `ctx.session`:
     *
     * ```ts
     * const menu = new Menu('root')
     * menu.dynamic(ctx => ctx.session.data.reduce((range, entry) => range.text(entry)), new Menu.Builder())
     * bot.command("start", async (ctx) => {
     *   await ctx.reply("Menu", {
     *      reply_markup: menu,
     *   });
     * });
     * ```
     *
     * @param menuFactory Async menu factory function
     */
    dynamic(rangeBuilder) {
        return this.addRange(async (ctx) => {
            const range = new MenuRange();
            const res = await rangeBuilder(ctx, range);
            if (res instanceof Menu) {
                throw new Error("Cannot use a `Menu` instance as a dynamic range, did you mean to return an instance of `Menu.Range` instead?");
            }
            return res instanceof MenuRange ? res : range;
        });
    }
    /**
     * Appends a given range to this range. This will effectively replay all
     * operations of the given range onto this range.
     *
     * @param range A potentially raw range
     */
    append(range) {
        if (range instanceof MenuRange) {
            this[ops].push(...range[ops]);
            return this;
        }
        else
            return this.addRange(range);
    }
}
exports.MenuRange = MenuRange;
_a = ops;
/**
 * A menu is a set of interactive buttons that is displayed beneath a message.
 * It uses an [inline keyboard](https://grammy.dev/plugins/keyboard.html) for
 * that, so in a sense, a menu is just an inline keyboard spiced up with
 * interactivity (such as navigation between multiple pages).
 *
 * ```ts
 * // Creating a simple menu
 * const menu = new Menu('my-menu-identifier')
 *   .text('A', ctx => ctx.reply('You pressed A!')).row()
 *   .text('B', ctx => ctx.reply('You pressed B!'))
 *
 * // Make it interactive
 * bot.use(menu)
 *
 * bot.command('start', async ctx => {
 *   // Send the menu:
 *   await ctx.reply('Check out this menu:', {
 *     reply_markup: menu
 *   })
 * })
 * ```
 *
 * Sending the menu is not directly possible via `bot.api.sendMessage`, only via
 * the context object, at least not yet.
 *
 * Check out the [official documentation](https://grammy.dev/plugins/menu.html)
 * to see how you can create menus that span several pages, how to navigate
 * between them, and more.
 */
class Menu extends MenuRange {
    /**
     * Creates a new menu with the given identifier.
     *
     * Check out the [official
     * documentation](https://grammy.dev/plugins/menu.html) to see how you can
     * create menus that span several pages, how to navigate between them, and
     * more.
     *
     * @param id Identifier of the menu
     * @param options Further configuration options
     */
    constructor(id, options = {}) {
        var _b, _c;
        super();
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Used internally by the menu, do not touch or you'll burn yourself.
         */
        Object.defineProperty(this, "inline_keyboard", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Proxy([], {
                get: () => {
                    throw new Error(`Cannot send menu '${this.id}'! Did you forget to use bot.use() for it?`);
                },
            })
        });
        if (id.includes("/")) {
            throw new Error(`You cannot use '/' in a menu identifier ('${id}')`);
        }
        this.index.set(id, this);
        const outdated = options.onMenuOutdated;
        this.options = {
            autoAnswer: (_b = options.autoAnswer) !== null && _b !== void 0 ? _b : true,
            onMenuOutdated: outdated === undefined || outdated === true
                ? "Menu was outdated, try again!"
                : outdated,
            fingerprint: (_c = options.fingerprint) !== null && _c !== void 0 ? _c : (() => ""),
        };
        if (options.onMenuOutdated === false &&
            options.fingerprint !== undefined) {
            throw new Error("Cannot use a fingerprint function when outdated detection is disabled!");
        }
    }
    /**
     * Registers a submenu. This makes it accessible for navigation, and sets
     * its parent menu to `this` menu.
     *
     * Optionally, you can specify the identifier of a different parent menu as
     * a second argument. The parent menu is the menu that is targeted when
     * backwards navigation is performed.
     *
     * Note that once you registered a submenu, it is sufficient to call
     * `bot.use(menu)` for the parent menu only. You do not need to make all
     * submenus interactive by passing them to `bot.use`.
     *
     * @param menus The menu to register, or an array of them
     * @param parent An optional parent menu identifier
     */
    register(menus, parent = this.id) {
        const arr = Array.isArray(menus) ? menus : [menus];
        const existing = arr.find((m) => this.index.has(m.id));
        if (existing !== undefined) {
            throw new Error(`Menu '${existing.id}' already registered!`);
        }
        this.freeze();
        for (const menu of arr) {
            menu.freeze();
            // `menu.index` includes `menu` itself
            menu.index.forEach((m, id) => {
                this.index.set(id, m);
                m.index = this.index;
            });
            menu.parent = parent;
        }
    }
    /**
     * Prevents this menu from being modified further in the future.
     */
    freeze() {
        if (Object.isFrozen(this[ops]))
            return;
        this[ops].push = () => {
            throw new Error("You cannot change a menu after your bot started! Did you mean to use a dynamic range instead?");
        };
        Object.freeze(this[ops]);
    }
    /**
     * Returns the menu instance for the given identifier. If the identifier is
     * the same as this menu's identifier, `this` is returned.
     *
     * @param id Menu identifier
     * @returns The identified menu
     */
    at(id) {
        const menu = this.index.get(id);
        if (menu === undefined) {
            const validIds = Array.from(this.index.keys())
                .map((k) => `'${k}'`)
                .join(", ");
            throw new Error(`Menu '${id}' is not known to menu '${this.id}'! Known submenus are: ${validIds}`);
        }
        return menu;
    }
    /**
     * Renders the menu to a static object of inline keyboard buttons by
     * concatenating all ranges, and applying the given context object to all
     * functions.
     *
     * @param ctx Context object to use
     */
    async render(ctx) {
        // Create renderer
        const renderer = createRenderer(ctx, async (btn, i, j) => {
            const text = await uniform(ctx, btn.text);
            if ("middleware" in btn) {
                const row = i.toString(16);
                const col = j.toString(16);
                const payload = await uniform(ctx, btn.payload, "");
                if (payload.includes("/")) {
                    throw new Error(`Could not render menu '${this.id}'! Payload must not contain a '/' character but was '${payload}'`);
                }
                return {
                    callback_data: `${this.id}/${row}/${col}/${payload}/`,
                    text,
                };
            }
            else
                return { ...btn, text };
        });
        // Render button array
        const rendered = await renderer(this[ops]);
        // Get shape of array
        const lengths = [rendered.length, ...rendered.map((row) => row.length)];
        // Generate fingerprint
        const fingerprint = await uniform(ctx, this.options.fingerprint);
        for (const row of rendered) {
            for (const btn of row) {
                if ("callback_data" in btn) {
                    // Inject hash values to detect keyboard changes
                    let type;
                    let data;
                    if (fingerprint) {
                        type = "f";
                        data = toNums(fingerprint);
                    }
                    else {
                        type = "h";
                        data = [...lengths, ...toNums(btn.text)];
                    }
                    btn.callback_data += type + tinyHash(data);
                }
            }
        }
        return rendered;
    }
    /**
     * Replaces known menu instances in the payload by their rendered versions.
     * A menu is known if it is contained in this menu's index. Only the
     * `reply_markup` property of the given object is checked for containing a
     * menu.
     *
     * @param payload Payload of API call
     * @param ctx Context object
     */
    async prepare(payload, ctx) {
        if (payload.reply_markup instanceof Menu) {
            const menu = this.index.get(payload.reply_markup.id);
            if (menu !== undefined) {
                const rendered = await menu.render(ctx);
                payload.reply_markup = { inline_keyboard: rendered };
            }
        }
    }
    middleware() {
        const composer = new deps_node_js_1.Composer((ctx, next) => {
            ctx.api.config.use(async (prev, method, payload, signal) => {
                const p = payload;
                if (Array.isArray(p.results)) {
                    await Promise.all(p.results.map((r) => this.prepare(r, ctx)));
                }
                else
                    await this.prepare(p, ctx);
                return await prev(method, payload, signal);
            });
            return next();
        });
        composer.on("callback_query:data").lazy(async (ctx) => {
            // Extract data from callback query data
            const [id, rowStr, colStr, payload, ...rest] = ctx
                .callbackQuery.data.split("/");
            const [type, ...h] = rest.join("/");
            const hash = h.join("");
            // Skip handling if this is not a known format
            if (!rowStr || !colStr)
                return [];
            if (type !== "h" && type !== "f")
                return [];
            // Get matched menu from index
            const menu = this.index.get(id);
            if (menu === undefined)
                return [];
            const row = parseInt(rowStr, 16);
            const col = parseInt(colStr, 16);
            if (row < 0 || col < 0) {
                const msg = `Invalid button position '${rowStr}/${colStr}'`;
                throw new Error(msg);
            }
            const outdated = menu.options.onMenuOutdated;
            // provide payload on `ctx.match` if it is not empty
            if (payload)
                ctx.match = payload;
            // Create middleware that installs `ctx.menu`
            const navInstaller = this.makeNavInstaller(menu);
            /** Defines what happens if the used menu is outdated */
            function menuIsOutdated() {
                if (outdated === false)
                    throw new Error("cannot happen");
                return typeof outdated !== "string"
                    ? [navInstaller, outdated]
                    : (ctx) => Promise.all([
                        ctx.answerCallbackQuery({ text: outdated }),
                        ctx.editMessageReplyMarkup({ reply_markup: menu }),
                    ]);
            }
            // Check fingerprint if used
            const fingerprint = await uniform(ctx, menu.options.fingerprint);
            const useFp = fingerprint !== "";
            if (useFp !== (type === "f"))
                return menuIsOutdated();
            if (useFp && tinyHash(toNums(fingerprint)) !== hash) {
                return menuIsOutdated();
            }
            // Create renderer and perform rendering
            const renderer = createRenderer(ctx, (btn) => btn);
            const range = await renderer(menu[ops]);
            // Check dimension
            const check = !useFp && outdated !== false;
            if (check && (row >= range.length || col >= range[row].length)) {
                return menuIsOutdated();
            }
            // Check correct button type
            const btn = range[row][col];
            if (!("middleware" in btn)) {
                if (check)
                    return menuIsOutdated();
                throw new Error(`Cannot invoke handlers because menu '${menu.id}' is outdated!`);
            }
            // Check dimensions
            if (check) {
                const rowCount = range.length;
                const rowLengths = range.map((row) => row.length);
                const label = await uniform(ctx, btn.text);
                const data = [rowCount, ...rowLengths, ...toNums(label)];
                const expectedHash = tinyHash(data);
                if (hash !== expectedHash)
                    return menuIsOutdated();
            }
            // Run handler
            const handler = btn.middleware;
            const mw = [navInstaller, ...handler];
            if (!menu.options.autoAnswer)
                return mw;
            const c = new deps_node_js_1.Composer();
            c.fork((ctx) => ctx.answerCallbackQuery());
            c.use(...mw);
            return c;
        });
        return composer.middleware();
    }
    makeNavInstaller(menu) {
        return async (ctx, next) => {
            let injectMenu = false;
            let targetMenu = menu;
            ctx.api.config.use((prev, method, payload, signal) => {
                var _b, _c;
                if (INJECT_METHODS.has(method) &&
                    !("reply_markup" in payload) &&
                    "chat_id" in payload &&
                    payload.chat_id !== undefined &&
                    payload.chat_id === ((_b = ctx.chat) === null || _b === void 0 ? void 0 : _b.id) &&
                    "message_id" in payload &&
                    payload.message_id !== undefined &&
                    payload.message_id === ((_c = ctx.msg) === null || _c === void 0 ? void 0 : _c.message_id)) {
                    injectMenu = false;
                    Object.assign(payload, { reply_markup: targetMenu });
                }
                return prev(method, payload, signal);
            });
            async function nav({ immediate } = {}, menu) {
                injectMenu = true;
                targetMenu = menu;
                if (immediate)
                    await ctx.editMessageReplyMarkup();
            }
            const controlPanel = {
                update: (config) => nav(config, menu),
                close: (config) => nav(config, undefined),
                nav: (to, config) => nav(config, menu.at(to)),
                back: (config) => {
                    const parent = menu.parent;
                    if (parent === undefined) {
                        throw new Error(`Cannot navigate back from menu '${menu.id}', no known parent!`);
                    }
                    return nav(config, menu.at(parent));
                },
            };
            // register ctx.menu
            Object.assign(ctx, { menu: controlPanel });
            try {
                // call handlers
                await next();
                // update menu if it could not be injected
                if (injectMenu)
                    await nav({ immediate: true }, targetMenu);
            }
            finally {
                // unregister ctx.menu
                Object.assign(ctx, { menu: undefined });
            }
        };
    }
}
exports.Menu = Menu;
/**
 * Creates an asynchronous rendering function for a given context object. A
 * rendering function takes a potentially dynamic menu range, and generates a
 * static two-dimensional array of button objects.
 *
 * Menu ranges store menu buttons. You need to pass a button transformer
 * function that turns a menu button into whatever button type you want to be
 * generated. For example, you may want to pass a function that generates inline
 * buttons. This function can be asynchronous.
 *
 * @param ctx Context object
 * @param buttonTransformer Button transformer
 * @returns Rendering function
 */
function createRenderer(ctx, buttonTransformer) {
    async function layout(keyboard, range) {
        const k = await keyboard;
        // Make static
        const btns = typeof range === "function" ? await range(ctx) : range;
        // Make raw
        if (btns instanceof MenuRange) {
            return btns[ops].reduce(layout, keyboard);
        }
        // Replay new buttons on top of partially constructed keyboard
        let first = true;
        for (const row of btns) {
            if (!first)
                k.push([]);
            const i = k.length - 1;
            for (const button of row) {
                const j = k[i].length;
                const btn = await buttonTransformer(button, i, j);
                k[i].push(btn);
            }
            first = false;
        }
        return k;
    }
    return (ops) => ops.reduce(layout, Promise.resolve([[]]));
}
/**
 * Turns an optional and potentially dynamic string into a regular string for a
 * given context object.
 *
 * @param ctx Context object
 * @param value Potentially dynamic string
 * @param fallback Fallback string value if value is undefined
 * @returns Plain old string
 */
function uniform(ctx, value, fallback = "") {
    if (value === undefined)
        return fallback;
    else if (typeof value === "function")
        return value(ctx);
    else
        return value;
}
